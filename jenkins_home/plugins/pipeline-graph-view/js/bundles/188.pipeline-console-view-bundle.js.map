{"version":3,"file":"188.pipeline-console-view-bundle.js","mappings":"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","sources":["webpack://pipeline-graph-view-plugin/./src/main/frontend/pipeline-console-view/pipeline-console/main/Ansi.tsx","webpack://pipeline-graph-view-plugin/./src/main/frontend/pipeline-console-view/pipeline-console/main/ConsoleLine.tsx","webpack://pipeline-graph-view-plugin/./src/main/frontend/pipeline-console-view/pipeline-console/main/ConsoleLogStream.tsx"],"sourcesContent":["import React from \"react\";\n\nexport interface Result {\n  isSelectGraphicRendition?: boolean;\n  escapeCode?: string; // input\n  setFG?: number | false; // 0-7 if a foreground color is specified\n  setBG?: number | false; // 0-7 if a background color is specified\n  resetFG?: boolean; // true if contains a reset back to default foreground\n  resetBG?: boolean; // true if contains a reset back to default background\n}\n\n/**\n * Parse an isolated escape code, looking for \"SelectGraphicsRendition\" codes specifically.\n *\n * Result:\n * ```\n * // Supported code\n * {\n *     isSelectGraphicRendition: true,\n *     escapeCode: string, // input\n *     setFG: integer | false, // 0-7 if a foreground color is specified\n *     setBG: integer | false, // 0-7 if a background color is specified\n *     resetFG: bool, // true if contains a reset back to default foreground\n *     resetBG: bool // true if contains a reset back to default background\n * }\n *\n * // Unsupported or malformed code:\n * {\n *     isSelectGraphicRendition: false,\n *     escapeCode: string // input\n * }\n * ```\n */\nexport function parseEscapeCode(escapeCode: string): Result {\n  const graphicsPattern = /^\\u001b\\[([;0-9]*)m$/; // We only care about SGR codes\n\n  const result: Result = {\n    isSelectGraphicRendition: false, // True when is a color / font command\n    escapeCode,\n  };\n\n  const match = graphicsPattern.exec(escapeCode);\n\n  if (match) {\n    result.isSelectGraphicRendition = true;\n    result.setFG = false;\n    result.setBG = false;\n    result.resetFG = false;\n    result.resetBG = false;\n\n    // Convert param string to array<int> with length > 1\n    const params = (match[1] || \"\")\n      .split(\";\")\n      .map((str) => parseInt(str || \"0\"));\n\n    // Now go through the ints, decode them into bg/fg info\n    for (const num of params) {\n      if (num >= 30 && num <= 37) {\n        result.setFG = num - 30; // Normal FG set\n      } else if (num >= 40 && num <= 47) {\n        result.setBG = num - 40; // Normal BG set\n      } else {\n        if (num === 38 || num === 0) {\n          result.resetFG = true;\n          result.setFG = false;\n        }\n\n        if (num === 48 || num === 0) {\n          result.resetBG = true;\n          result.setBG = false;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Break up a string into an array of plain strings and escape codes. Returns [input] if no codes present.\n */\nexport function tokenizeANSIString(input?: string): string[] | Result[] {\n  if (typeof input !== \"string\") {\n    return [];\n  }\n\n  const len = input.length;\n\n  if (len === 0) {\n    return [];\n  }\n\n  /*\n    loopCounter         - Where should the next loop start looping for escape codes.\n    escapeCodeIndex     - The index in the string of the next ANSI escape code or -1.\n    parsedPointer       - The parse pointer how far in the string have we parsed.\n                          This will === loopCounter unless there are commented ANSI escape characters.\n    commentStartIndex   - The start index of the next comment block, or -1.\n    commentEndIndex     - The end index of the next comment block, or -1.\n  */\n  let loopCounter = 0,\n    escapeCodeIndex = 0,\n    parsedPointer = 0,\n    // comment start\n    commentStartIndex = 0,\n    // comment end\n    commentEndIndex = 0;\n  const result: string[] | Result[] = [];\n\n  while (loopCounter < len) {\n    //--------------------------------------------------------------------------\n    //  Find next escape code\n    escapeCodeIndex = input.indexOf(\"\\x1b\", loopCounter);\n\n    if (escapeCodeIndex === -1) {\n      // No more escape codes\n      break;\n    }\n\n    // Check if escape code is commented\n    commentStartIndex = input.indexOf(\"<!--\", loopCounter);\n    commentEndIndex = input.indexOf(\"-->\", commentStartIndex);\n    if (commentEndIndex !== -1) {\n      commentEndIndex += 3;\n    }\n    if (\n      escapeCodeIndex > commentStartIndex &&\n      escapeCodeIndex < commentEndIndex\n    ) {\n      // Skip past the comment\n      loopCounter = commentEndIndex;\n      continue;\n    }\n\n    //--------------------------------------------------------------------------\n    //  Capture any text between the start pointer and the escape code\n\n    if (escapeCodeIndex > loopCounter) {\n      result.push(input.substring(loopCounter, escapeCodeIndex));\n      loopCounter = escapeCodeIndex; // Advance our start pointer to the beginning of the escape code\n    }\n\n    //--------------------------------------------------------------------------\n    //  Find the end of the escape code (a char from 64 - 126 indicating command)\n\n    escapeCodeIndex += 2; // Skip past ESC and '['\n\n    let code = input.charCodeAt(escapeCodeIndex);\n    while (escapeCodeIndex < len && (code < 64 || code > 126)) {\n      escapeCodeIndex++;\n      code = input.charCodeAt(escapeCodeIndex);\n    }\n\n    //--------------------------------------------------------------------------\n    //  Create token for the escape code\n\n    // TODO fix type checking\n    const parsedEscapeCode: any = parseEscapeCode(\n      input.substring(loopCounter, escapeCodeIndex + 1),\n    );\n    result.push(parsedEscapeCode);\n\n    //--------------------------------------------------------------------------\n    //  Keep looking in the rest of the string\n\n    loopCounter = escapeCodeIndex + 1;\n    // Move parsedPointer as we have processes the text to this point.\n    parsedPointer = loopCounter;\n  }\n\n  if (parsedPointer < len) {\n    result.push(input.substr(parsedPointer));\n  }\n\n  return result;\n}\n\n/**\n * Takes an array of string snippets and parsed escape codes produced bv tokenizeANSIString, and creates\n * an array of strings and spans with classNames for attributes.\n */\nexport function makeReactChildren(\n  tokenizedInput: string[] | Result[],\n  key: string,\n) {\n  const result = [];\n  let currentState: Result = {\n    setFG: false,\n    setBG: false,\n  };\n\n  for (let i = 0; i < tokenizedInput.length; i++) {\n    let codeOrString = tokenizedInput[i];\n    if (typeof codeOrString === \"string\") {\n      // Need to output a <span> or plain text if there's no interesting current state\n      if (!currentState.setFG && !currentState.setBG) {\n        result.push(\n          <div\n            dangerouslySetInnerHTML={{ __html: codeOrString }}\n            key={`${key}-${i}`}\n          />,\n        );\n      } else {\n        const classNames = [];\n\n        if (typeof currentState.setFG === \"number\") {\n          classNames.push(`ansi-fg-${currentState.setFG}`);\n        }\n        if (typeof currentState.setBG === \"number\") {\n          classNames.push(`ansi-bg-${currentState.setBG}`);\n        }\n\n        result.push(\n          <span className={classNames.join(\" \")}>{codeOrString}</span>,\n        );\n      }\n    } else if (codeOrString.isSelectGraphicRendition) {\n      // Update the current FG / BG colors for the next text span\n      const nextState = { ...currentState };\n\n      if (codeOrString.resetFG) {\n        nextState.setFG = false;\n      }\n      if (codeOrString.resetBG) {\n        nextState.setBG = false;\n      }\n\n      if (typeof codeOrString.setFG === \"number\") {\n        nextState.setFG = codeOrString.setFG;\n      }\n      if (typeof codeOrString.setBG === \"number\") {\n        nextState.setBG = codeOrString.setBG;\n      }\n\n      currentState = nextState;\n    }\n  }\n\n  return result;\n}\n","import React from \"react\";\nimport { useEffect, useRef } from \"react\";\nimport { makeReactChildren, tokenizeANSIString } from \"./Ansi\";\n\nexport interface ConsoleLineProps {\n  lineNumber: string;\n  content: string;\n  stepId: string;\n  startByte: number;\n  heightCallback: (height: number) => void;\n}\n\ndeclare global {\n  interface Window {\n    Behaviour: any;\n  }\n}\n\n// Console output line\nexport const ConsoleLine = (props: ConsoleLineProps) => {\n  const ref = useRef<HTMLDivElement>(null);\n  useEffect(() => {\n    const height = ref.current ? ref.current.getBoundingClientRect().height : 0;\n    props.heightCallback(height);\n\n    // apply any behaviour selectors to the new content, e.g. for input step\n    window.Behaviour.applySubtree(\n      document.getElementById(`${props.stepId}-${props.lineNumber}`),\n    );\n  }, []);\n\n  return (\n    <pre\n      style={{ background: \"none\", border: \"none\" }}\n      className=\"console-output-line\"\n      key={`console-line-pre${props.lineNumber}`}\n    >\n      <div\n        className=\"console-output-line-anchor\"\n        id={`log-${props.lineNumber}`}\n        key={`${props.lineNumber}-anchor`}\n      />\n      <div\n        className=\"console-output-line\"\n        key={`${props.lineNumber}-body`}\n        ref={ref}\n      >\n        <a\n          className=\"console-line-number\"\n          href={`?start-byte=${props.startByte}&selected-node=${props.stepId}#log-${props.lineNumber}`}\n          style={{\n            width: Math.max(9 * String(props.lineNumber).length, 30) + \"px\",\n          }}\n        >\n          {props.lineNumber}\n        </a>\n        <div\n          id={`${props.stepId}-${props.lineNumber}`}\n          className=\"console-text\"\n        >\n          {makeReactChildren(\n            tokenizeANSIString(props.content),\n            `${props.stepId}-${props.lineNumber}`,\n          )}\n        </div>\n      </div>\n    </pre>\n  );\n};\n","import React, { useCallback, useState, useEffect, useRef } from \"react\";\nimport { Virtuoso, VirtuosoHandle } from \"react-virtuoso\";\nimport { Result, StepInfo, StepLogBufferInfo } from \"./PipelineConsoleModel\";\nimport { ConsoleLine } from \"./ConsoleLine\";\n\nexport default function ConsoleLogStream(props: ConsoleLogStreamProps) {\n  const appendInterval = useRef<NodeJS.Timeout | null>(null);\n  const virtuosoRef = useRef<VirtuosoHandle>(null);\n  const [stickToBottom, setStickToBottom] = useState(false);\n  const [maxConsoleLineHeight, setMaxConsoleLineHeight] = useState(1);\n\n  useEffect(() => {\n    return () => {\n      if (appendInterval.current) {\n        clearInterval(appendInterval.current);\n      }\n    };\n  }, []);\n\n  useEffect(() => {\n    if (stickToBottom && props.logBuffer.lines.length > 0) {\n      // Scroll to bottom of the log stream\n      if (virtuosoRef.current && props.logBuffer.lines) {\n        requestAnimationFrame(() => {\n          const scrollTarget = document.documentElement.scrollHeight;\n          window.scrollTo({ top: scrollTarget });\n        });\n      }\n    }\n  }, [props.logBuffer.lines]);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollPosition = window.scrollY + window.innerHeight;\n      const pageHeight = document.body.scrollHeight;\n      const isAtBottom = pageHeight - scrollPosition < 300;\n\n      setStickToBottom(isAtBottom);\n    };\n\n    window.addEventListener(\"scroll\", handleScroll);\n    return () => window.removeEventListener(\"scroll\", handleScroll);\n  }, []);\n\n  useEffect(() => {\n    if (stickToBottom && shouldRequestMoreLogs()) {\n      if (!appendInterval.current) {\n        appendInterval.current = setInterval(() => {\n          props.handleMoreConsoleClick(\n            props.step.id,\n            props.logBuffer.startByte,\n          );\n        }, 1000);\n      }\n    } else if (appendInterval.current) {\n      clearInterval(appendInterval.current);\n      appendInterval.current = null;\n    }\n  }, [stickToBottom, props.step, props.logBuffer]);\n\n  const consoleLineHeightCallback = useCallback(\n    (height: number) => {\n      if (height > maxConsoleLineHeight || maxConsoleLineHeight === 1) {\n        setMaxConsoleLineHeight(height);\n      }\n    },\n    [maxConsoleLineHeight],\n  );\n\n  const shouldRequestMoreLogs = () => {\n    return props.step.state === Result.running || props.logBuffer.startByte < 0;\n  };\n\n  return (\n    <Virtuoso\n      useWindowScroll\n      ref={virtuosoRef}\n      data={props.logBuffer.lines}\n      itemContent={(index: number, content: string) => (\n        <ConsoleLine\n          lineNumber={String(index)}\n          content={content}\n          stepId={props.step.id}\n          startByte={props.logBuffer.startByte}\n          heightCallback={consoleLineHeightCallback}\n        />\n      )}\n    />\n  );\n}\n\nexport interface ConsoleLogStreamProps {\n  logBuffer: StepLogBufferInfo;\n  handleMoreConsoleClick: (nodeId: string, startByte: number) => void;\n  step: StepInfo;\n  maxHeightScale: number;\n}\n"],"names":["parseEscapeCode","escapeCode","result","isSelectGraphicRendition","match","exec","setFG","setBG","resetFG","resetBG","_step","_iterator","_createForOfIteratorHelper","split","map","str","parseInt","s","n","done","num","value","err","e","f","ConsoleLine","props","ref","useRef","useEffect","height","current","getBoundingClientRect","heightCallback","window","Behaviour","applySubtree","document","getElementById","concat","stepId","lineNumber","React","style","background","border","className","key","id","href","startByte","width","Math","max","String","length","tokenizedInput","currentState","i","codeOrString","classNames","push","join","dangerouslySetInnerHTML","__html","nextState","_objectSpread","makeReactChildren","input","len","loopCounter","escapeCodeIndex","parsedPointer","commentStartIndex","commentEndIndex","indexOf","substring","code","charCodeAt","parsedEscapeCode","substr","tokenizeANSIString","content","ConsoleLogStream","appendInterval","virtuosoRef","_useState2","_slicedToArray","useState","stickToBottom","setStickToBottom","_useState4","maxConsoleLineHeight","setMaxConsoleLineHeight","clearInterval","logBuffer","lines","requestAnimationFrame","scrollTarget","documentElement","scrollHeight","scrollTo","top","handleScroll","scrollPosition","scrollY","innerHeight","pageHeight","body","addEventListener","removeEventListener","shouldRequestMoreLogs","setInterval","handleMoreConsoleClick","step","consoleLineHeightCallback","useCallback","state","Result","running","Virtuoso","useWindowScroll","data","itemContent","index"],"sourceRoot":""}